
//调试一：阻塞区域像素坐标。输入layer0，区域编号1
int main(int argc, char** argv)
{
    try {
        std::string filename = (argc >= 2) ? argv[1] : "testcase.kicad_pcb";

        Grid grid;
        // 如需修改 inputScale，请在 SetUp 之前调用：
        // grid.setInputScale(1);  // 例如：1 像素 = 1 mm
        grid.SetUp(filename);

        int layer = 0;
        int areaID = 1;

        auto items = CollectBlockedPixelsWithReal(grid, layer, areaID);

        if (items.empty()) {
            std::cout << "[提示] 未找到层 " << layer << " 的阻塞区域 " << areaID << " 或该区域为空。\n";
            return 0;
        }

        std::cout << "文件: " << filename << "\n"
            << "层: " << layer << "，阻塞区域: " << areaID
            << "，像素总数: " << items.size() << "\n\n";

        std::cout << std::fixed << std::setprecision(5);
        for (const auto& bp : items) {
            std::cout << "Pixel( row=" << bp.row1 << ", col=" << bp.col1 << " )  ->  "
                << "Real(mm): (x=" << bp.x_mm << ", y=" << bp.y_mm << ")\n";
        }

        // （可选）打印包围盒四角
        auto corners = GetBlockedAreaBBoxCorners_1Based(grid, layer, areaID);
        std::cout << "\nBBox corners (LB, RB, RT, LT) 1-based:\n";
        const char* names[4] = { "LB","RB","RT","LT" };
        for (int i = 0; i < 4; i++) {
            std::cout << names[i] << ": (row=" << corners[i].first
                << ", col=" << corners[i].second << ")\n";
        }

    }
    catch (const std::exception& ex) {
        std::cerr << "[错误] " << ex.what() << "\n";
        return 1;
    }
    return 0;
}



//调试二：
int main()
{
    try {
        std::string pcb = "testcase.kicad_pcb"; // 或 "L92.txt" / "A30.txt"
        int layer = 1;
        int areaID = 1;
        int m_expand = 4;              // 你可以改

        Grid grid;
        grid.SetUp(pcb);                  // 按你的工程读取 inputScale 等

        auto pxs = GetBlockedAreaPixels_1Based(grid, layer, areaID);
        if (pxs.empty()) {
            std::cout << "未找到该阻塞区域。\n";
            return 0;
        }

        auto bbox = ComputeBBoxFromPixels1(pxs);

        ClipReport rep;
        auto ebbox = ExpandBBoxByMPixelsCompensated(bbox, m_expand, grid, &rep);

        // 像素四角（LB,RB,RT,LT）
        auto pxCorners = BBoxCorners_LB_RB_RT_LT(ebbox);
        std::cout << "[像素边框四角] (LB, RB, RT, LT):\n";
        std::cout << "  LB = (" << pxCorners[0].first << "," << pxCorners[0].second << ")\n";
        std::cout << "  RB = (" << pxCorners[1].first << "," << pxCorners[1].second << ")\n";
        std::cout << "  RT = (" << pxCorners[2].first << "," << pxCorners[2].second << ")\n";
        std::cout << "  LT = (" << pxCorners[3].first << "," << pxCorners[3].second << ")\n";

        // 现实四角（LT, LB, RT, RB）
        auto realCorners = RealCorners_LT_LB_RT_RB(grid, ebbox);
        std::cout << std::fixed << std::setprecision(5);
        std::cout << "\n[现实边框四角(mm)] (LT, LB, RT, RB):\n";
        std::cout << "  LT = (" << realCorners[0].first << ", " << realCorners[0].second << ")\n";
        std::cout << "  LB = (" << realCorners[1].first << ", " << realCorners[1].second << ")\n";
        std::cout << "  RT = (" << realCorners[2].first << ", " << realCorners[2].second << ")\n";
        std::cout << "  RB = (" << realCorners[3].first << ", " << realCorners[3].second << ")\n";

        // 打印是否贴边与补偿信息
        std::cout << "\n[边界剪裁/补偿报告]\n";
        if (rep.left)   std::cout << "  左侧贴边，缺 " << rep.left_deficit_px << " px，已补到右侧\n";
        if (rep.right)  std::cout << "  右侧贴边，缺 " << rep.right_deficit_px << " px，已补到左侧\n";
        if (rep.top)    std::cout << "  上侧贴边，缺 " << rep.top_deficit_px << " px，已补到下侧\n";
        if (rep.bottom) std::cout << "  下侧贴边，缺 " << rep.bottom_deficit_px << " px，已补到上侧\n";
        if (!rep.left && !rep.right && !rep.top && !rep.bottom)
            std::cout << "  未触碰 PCB 边界，无需补偿。\n";

    }
    catch (const std::exception& e) {
        std::cerr << "[Separate2] Error: " << e.what() << "\n";
        return 1;
    }
    return 0;
}





//调试四：将顶点存储进去vector
// ========== 主函数调试 GetExpandedPCBRealCorners ==========
int main() {
    try {
        // 1. 初始化Grid，读取PCB文件
        Grid grid;
        std::string filename = "testcase.kicad_pcb";  // 请替换为实际文件路径
        std::cout << "正在读取PCB文件: " << filename << std::endl;
        grid.SetUp(filename);

        std::cout << "Grid初始化成功!" << std::endl;
        std::cout << "网格尺寸: " << grid.width << " x " << grid.height << std::endl;
        std::cout << "层数: " << grid.Layers << std::endl;
        std::cout << "输入比例: " << grid.inputScale << std::endl;
        std::cout << "坐标范围: x[" << grid.min_x << ", " << grid.max_x << "], y[" << grid.min_y << ", " << grid.max_y << "]" << std::endl;

        // 2. 显示可用的层信息
        std::cout << "\n=== 可用层信息 ===" << std::endl;
        for (int i = 0; i < grid.layerName.size(); ++i) {
            std::cout << "层 " << i << ": " << grid.layerName[i] << std::endl;
        }

        // 3. 分析每层的阻塞区域
        std::cout << "\n=== 各层阻塞区域分析 ===" << std::endl;
        for (int layer = 0; layer < grid.Layers; ++layer) {
            try {
                LayerBlockedAnalysis la = BlockedAreaAnalyzer::analyzeLayerBlockedAreas(grid, layer);
                std::cout << "层 " << layer << " (" << getLayerNameById(grid, layer)
                    << "): 找到 " << la.blockedAreas.size() << " 个阻塞区域" << std::endl;

                for (const auto& area : la.blockedAreas) {
                    std::cout << "  阻塞区域ID: " << area.areaID
                        << ", 像素数: " << area.cells.size()<<std::endl;
                }
            }
            catch (const std::exception& e) {
                std::cout << "层 " << layer << " 分析失败: " << e.what() << std::endl;
            }
        }

        // 4. 测试获取扩展后小PCB的角点坐标
        std::cout << "\n=== 测试获取扩展后小PCB角点坐标 ===" << std::endl;

        // 选择测试参数（可以根据上面的分析结果调整）
        int testLayer = 1;          // 测试层号
        int testBlockedAreaID = 1;  // 测试阻塞区域ID
        int expandPixels = 4;       // 扩展像素数

        std::cout << "测试参数: 层=" << testLayer
            << "(" << getLayerNameById(grid, testLayer) << ")"
            << ", 阻塞区域ID=" << testBlockedAreaID
            << ", 扩展像素=" << expandPixels << std::endl;

        // 获取阻塞区域像素
        auto blockedPixels = GetBlockedAreaPixels_1Based(grid, testLayer, testBlockedAreaID);
        if (blockedPixels.empty()) {
            std::cout << "警告: 未找到阻塞区域 " << testBlockedAreaID << "，将尝试其他区域..." << std::endl;

            // 尝试第一个可用的阻塞区域
            LayerBlockedAnalysis la = BlockedAreaAnalyzer::analyzeLayerBlockedAreas(grid, testLayer);
            if (!la.blockedAreas.empty()) {
                testBlockedAreaID = la.blockedAreas[0].areaID;
                blockedPixels = GetBlockedAreaPixels_1Based(grid, testLayer, testBlockedAreaID);
                std::cout << "改为使用阻塞区域ID: " << testBlockedAreaID << std::endl;
            }
        }

        if (!blockedPixels.empty()) {
            std::cout << "找到阻塞区域像素数: " << blockedPixels.size() << std::endl;

            // 计算原始包围盒
            BBoxPx1 originalBBox = ComputeBBoxFromPixels1(blockedPixels);
            std::cout << "原始包围盒: 行[" << originalBBox.row_min << "-" << originalBBox.row_max
                << "], 列[" << originalBBox.col_min << "-" << originalBBox.col_max << "]" << std::endl;

            // 获取扩展后的小PCB角点坐标
            auto corners = GetExpandedPCBRealCorners(grid, testLayer, testBlockedAreaID, expandPixels);

            // 输出结果
            std::cout << "\n=== 扩展后小PCB的四个角点坐标 ===" << std::endl;
            std::cout << std::fixed << std::setprecision(6);
            std::vector<std::string> cornerNames = { "左上(LT)", "右上(RT)", "右下(RB)", "左下(LB)" };

            for (size_t i = 0; i < corners.size(); ++i) {
                std::cout << cornerNames[i] << ": ("
                    << corners[i].first << " mm, "
                    << corners[i].second << " mm)" << std::endl;
            }

            // 5. 将角点坐标存储到vector中（按需使用）
            std::vector<std::pair<double, double>> pcbCorners = corners;
            std::cout << "\n角点坐标已存储到vector中，大小: " << pcbCorners.size() << std::endl;

            // 6. 可选：创建对应的RealRectMM用于线段相交检测
            RealRectMM pcbBox;
            pcbBox.x_left = corners[0].first;   // 左上x
            pcbBox.y_top = corners[0].second;   // 左上y  
            pcbBox.x_right = corners[1].first;  // 右上x
            pcbBox.y_bot = corners[2].second;   // 右下y

            std::cout << "\n=== 小PCB边界框 ===" << std::endl;
            std::cout << "左边界 x_left: " << pcbBox.x_left << " mm" << std::endl;
            std::cout << "上边界 y_top: " << pcbBox.y_top << " mm" << std::endl;
            std::cout << "右边界 x_right: " << pcbBox.x_right << " mm" << std::endl;
            std::cout << "下边界 y_bot: " << pcbBox.y_bot << " mm" << std::endl;

           

        }
        else {
            std::cout << "错误: 在层 " << testLayer << " 上未找到任何阻塞区域" << std::endl;
        }

    }
    catch (const std::exception& e) {
        std::cerr << "程序运行出错: " << e.what() << std::endl;
        return 1;
    }

    std::cout << "\n程序执行完成!" << std::endl;
    return 0;
}



//调试五:输出最终点
// ========== 主函数 ==========
int main() {
    try {
        // 1. 初始化Grid，读取PCB文件
        Grid grid;
        std::string filename = "testcase.kicad_pcb";  // 请替换为实际文件路径
        std::cout << "正在读取PCB文件: " << filename << std::endl;
        grid.SetUp(filename);

        std::cout << "Grid初始化成功!" << std::endl;
        std::cout << "网格尺寸: " << grid.width << " x " << grid.height << std::endl;
        std::cout << "层数: " << grid.Layers << std::endl;
        std::cout << "输入比例: " << grid.inputScale << std::endl;
        std::cout << "坐标范围: x[" << grid.min_x << ", " << grid.max_x << "], y[" << grid.min_y << ", " << grid.max_y << "]" << std::endl;

        // 2. 显示可用的层信息
        std::cout << "\n=== 可用层信息 ===" << std::endl;
        for (int i = 0; i < grid.layerName.size(); ++i) {
            std::cout << "层 " << i << ": " << grid.layerName[i] << std::endl;
        }

        // 3. 分析每层的阻塞区域
        std::cout << "\n=== 各层阻塞区域分析 ===" << std::endl;
        for (int layer = 0; layer < grid.Layers; ++layer) {
            try {
                LayerBlockedAnalysis la = BlockedAreaAnalyzer::analyzeLayerBlockedAreas(grid, layer);
                std::cout << "层 " << layer << " (" << getLayerNameById(grid, layer)
                    << "): 找到 " << la.blockedAreas.size() << " 个阻塞区域" << std::endl;

                for (const auto& area : la.blockedAreas) {
                    std::cout << "  阻塞区域ID: " << area.areaID
                        << ", 像素数: " << area.cells.size() << std::endl;
                }
            }
            catch (const std::exception& e) {
                std::cout << "层 " << layer << " 分析失败: " << e.what() << std::endl;
            }
        }

        // 4. 测试获取扩展后小PCB的角点坐标
        std::cout << "\n=== 测试获取扩展后小PCB角点坐标 ===" << std::endl;

        // 选择测试参数（可以根据上面的分析结果调整）
        int testLayer = 1;          // 测试层号
        int testBlockedAreaID = 1;  // 测试阻塞区域ID
        int expandPixels = 4;       // 扩展像素数

        std::cout << "测试参数: 层=" << testLayer
            << "(" << getLayerNameById(grid, testLayer) << ")"
            << ", 阻塞区域ID=" << testBlockedAreaID
            << ", 扩展像素=" << expandPixels << std::endl;

        // 获取阻塞区域像素
        auto blockedPixels = GetBlockedAreaPixels_1Based(grid, testLayer, testBlockedAreaID);
        if (blockedPixels.empty()) {
            std::cout << "警告: 未找到阻塞区域 " << testBlockedAreaID << "，将尝试其他区域..." << std::endl;

            // 尝试第一个可用的阻塞区域
            LayerBlockedAnalysis la = BlockedAreaAnalyzer::analyzeLayerBlockedAreas(grid, testLayer);
            if (!la.blockedAreas.empty()) {
                testBlockedAreaID = la.blockedAreas[0].areaID;
                blockedPixels = GetBlockedAreaPixels_1Based(grid, testLayer, testBlockedAreaID);
                std::cout << "改为使用阻塞区域ID: " << testBlockedAreaID << std::endl;
            }
        }

        if (!blockedPixels.empty()) {
            std::cout << "找到阻塞区域像素数: " << blockedPixels.size() << std::endl;

            // 计算原始包围盒
            BBoxPx1 originalBBox = ComputeBBoxFromPixels1(blockedPixels);
            std::cout << "原始包围盒: 行[" << originalBBox.row_min << "-" << originalBBox.row_max
                << "], 列[" << originalBBox.col_min << "-" << originalBBox.col_max << "]" << std::endl;

            // 获取扩展后的小PCB角点坐标
            auto corners = GetExpandedPCBRealCorners(grid, testLayer, testBlockedAreaID, expandPixels);

            // 输出结果
            std::cout << "\n=== 扩展后小PCB的四个角点坐标 ===" << std::endl;
            std::cout << std::fixed << std::setprecision(6);
            std::vector<std::string> cornerNames = { "左上(LT)", "右上(RT)", "右下(RB)", "左下(LB)" };

            for (size_t i = 0; i < corners.size(); ++i) {
                std::cout << cornerNames[i] << ": ("
                    << corners[i].first << " mm, "
                    << corners[i].second << " mm)" << std::endl;
            }

            // 5. 将角点坐标存储到vector中
            std::vector<std::pair<double, double>> pcbCorners = corners;
            std::cout << "\n角点坐标已存储到vector中，大小: " << pcbCorners.size() << std::endl;

            // 6. 创建对应的RealRectMM
            RealRectMM pcbBox;
            pcbBox.x_left = corners[0].first;   // 左上x
            pcbBox.y_top = corners[0].second;   // 左上y  
            pcbBox.x_right = corners[1].first;  // 右上x
            pcbBox.y_bot = corners[2].second;   // 右下y

            std::cout << "\n=== 小PCB边界框 ===" << std::endl;
            std::cout << "左边界 x_left: " << pcbBox.x_left << " mm" << std::endl;
            std::cout << "上边界 y_top: " << pcbBox.y_top << " mm" << std::endl;
            std::cout << "右边界 x_right: " << pcbBox.x_right << " mm" << std::endl;
            std::cout << "下边界 y_bot: " << pcbBox.y_bot << " mm" << std::endl;

            // 7. 将边界框存储到vector中
            std::vector<double> pcbBounds;
            pcbBounds.reserve(4);
            pcbBounds.push_back(pcbBox.x_left);
            pcbBounds.push_back(pcbBox.y_top);
            pcbBounds.push_back(pcbBox.x_right);
            pcbBounds.push_back(pcbBox.y_bot);

            std::cout << "\n边界框已存储到vector中，大小: " << pcbBounds.size() << std::endl;
            std::vector<std::string> boundNames = { "左边界", "上边界", "右边界", "下边界" };
            for (size_t i = 0; i < pcbBounds.size(); ++i) {
                std::cout << boundNames[i] << ": " << pcbBounds[i] << " mm" << std::endl;
            }

            // 8. 查找小PCB内的所有交点和终止点
            std::cout << "\n=== 开始查找小PCB内的交点和终止点 ===" << std::endl;
            auto intersectionPoints = FindIntersectionsAndEndpointsInSmallPCB(grid, testLayer, testBlockedAreaID, expandPixels);

            std::cout << "\n=== 最终结果汇总 ===" << std::endl;
            std::cout << "共找到 " << intersectionPoints.size() << " 个点:" << std::endl;
            for (size_t i = 0; i < intersectionPoints.size(); ++i) {
                std::cout << "点 " << i + 1 << ": (" << intersectionPoints[i].first
                    << ", " << intersectionPoints[i].second << ")" << std::endl;
            }

            // 9. 可选：将交点坐标保存到文件或其他处理
            std::cout << "\n所有处理完成!" << std::endl;

        }
        else {
            std::cout << "错误: 在层 " << testLayer << " 上未找到任何阻塞区域" << std::endl;
        }

    }
    catch (const std::exception& e) {
        std::cerr << "程序运行出错: " << e.what() << std::endl;
        return 1;
    }

    std::cout << "\n程序执行完成!" << std::endl;
    return 0;
}



//调试七：保证精度
// ========== 修正精度的简约主函数 ==========
int main() {
    try {
        // 1. 初始化Grid
        Grid grid;
        std::string filename = "testcase.kicad_pcb";
        grid.SetUp(filename);
        std::cout << "Grid初始化成功! 网格尺寸: " << grid.width << " x " << grid.height << std::endl;

        // 2. 设置参数
        int layerId = 1;           // 层序号
        int blockedAreaId = 2;     // 阻塞区域编号
        int expandPixels = 3;      // 扩展像素数

        std::cout << "参数: 层=" << layerId << "(" << getLayerNameById(grid, layerId)
            << "), 阻塞区域=" << blockedAreaId << ", 扩展=" << expandPixels << "像素" << std::endl;

        // 3. 获取小PCB边界框
        auto corners = GetExpandedPCBRealCorners(grid, layerId, blockedAreaId, expandPixels);

        // 设置高精度输出
        std::cout << std::fixed << std::setprecision(5);
        std::cout << "小PCB边界框: 左=" << corners[0].first << ", 上=" << corners[0].second
            << ", 右=" << corners[1].first << ", 下=" << corners[2].second << std::endl;

        // 4. 查找交点和终止点
        auto points = FindIntersectionsAndEndpointsInSmallPCB(grid, layerId, blockedAreaId, expandPixels);

        // 5. 输出最终结果
        std::cout << "\n=== 最终结果 ===" << std::endl;
        std::cout << "共找到 " << points.size() << " 个点:" << std::endl;
        for (size_t i = 0; i < points.size(); ++i) {
            std::cout << "点 " << i + 1 << ": (" << points[i].x << ", " << points[i].y
                << "), 网络: " << points[i].net << std::endl;
        }

    }
    catch (const std::exception& e) {
        std::cerr << "程序运行出错: " << e.what() << std::endl;
        return 1;
    }

    std::cout << "程序执行完成!" << std::endl;
    return 0;
}
